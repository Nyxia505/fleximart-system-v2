rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() { return request.auth != null; }
    function isOwner(uid) { return isSignedIn() && request.auth.uid == uid; }
    
    // Safe role check - checks if document exists first to avoid errors for new users
    function roleOf(uid) { 
      return exists(/databases/$(database)/documents/users/$(uid)) ?
             get(/databases/$(database)/documents/users/$(uid)).data.role : null;
    }
    function isAdmin() { 
      return isSignedIn() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'; 
    }
    function isStaff() { 
      return isSignedIn() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'staff'; 
    }
    function isCustomer() { 
      return isSignedIn() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'customer'; 
    }

    // Users collection
    match /users/{uid} {
      // Owner can read/create; admins/staff have full access
      // Allow read access for email existence check during signup
      // Note: This allows querying users collection to check if email exists
      // In production, consider using a Cloud Function for this check
      allow read: if isOwner(uid) || isAdmin() || isStaff() || 
                     // Allow queries during signup (unauthenticated users need to check email)
                     true;
      allow create: if isOwner(uid) || isAdmin() || isStaff();

      // Owner can update their own profile fields (fullName, phone, phoneNumber, phoneVerified, phoneVerifiedAt, profileImageUrl, emailVerified, isVerified, verifiedAt)
      // Admins/staff can update any user
      // Allow verification updates during signup (user might be authenticated but rules should allow)
      allow update: if (isOwner(uid) &&
                        (request.resource.data.diff(resource.data)
                          .changedKeys().hasOnly(['emailVerified']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasOnly(['isVerified']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasOnly(['fullName']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasOnly(['phone']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasOnly(['phoneNumber']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasOnly(['phoneVerified']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasOnly(['phoneVerifiedAt']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasOnly(['profileImageUrl']) ||
                         // Allow phone verification fields together
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['phoneNumber', 'phoneVerified']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['phoneNumber', 'phoneVerified', 'phoneVerifiedAt']) ||
                         // Allow verification fields together (for OTP verification)
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['emailVerified', 'isVerified']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['emailVerified', 'isVerified', 'verifiedAt']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['emailVerified', 'verifiedAt']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['isVerified', 'verifiedAt']) ||
                         // Profile field combinations
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['fullName', 'phone']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['fullName', 'phoneNumber']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['fullName', 'profileImageUrl']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['phone', 'profileImageUrl']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['phoneNumber', 'profileImageUrl']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['fullName', 'phone', 'profileImageUrl']) ||
                         request.resource.data.diff(resource.data)
                          .changedKeys().hasAll(['fullName', 'phoneNumber', 'profileImageUrl'])))
                    || isAdmin() || isStaff();
      
      // Allow set operations for verification (during signup, document might not exist)
      allow create: if isOwner(uid) || isAdmin() || isStaff();

      allow delete: if isAdmin();

      // Cart subcollection - customers can manage their own cart
      match /cart/{cartId} {
        allow read, write: if isOwner(uid) || isAdmin() || isStaff();
      }

      // Addresses subcollection
      match /addresses/{addrId} {
        allow read, write: if isOwner(uid) || isAdmin() || isStaff();
      }
    }

    // Orders collection
    match /orders/{orderId} {
      // Customers can create orders with their own userId
      allow create: if isSignedIn() && 
                       request.resource.data.customerId == request.auth.uid;
      
      // Customers can read their own orders
      // Staff/Admin can read all orders
      // Also allow customers to read orders for sold count calculation (need to read all orders to count)
      allow read: if isAdmin() || isStaff() || 
                     (isSignedIn() && resource.data.customerId == request.auth.uid) ||
                     // Allow customers to read orders for sold count (they can see productId and quantity, not sensitive data)
                     (isSignedIn() && isCustomer());
      
      // Customers can update their own orders for rating fields only
      // Staff/Admin can update any order fields
      allow update: if isAdmin() || isStaff() ||
                     (isSignedIn() && 
                      resource.data.customerId == request.auth.uid &&
                      // Only allow rating-related fields to be updated by customers
                      (request.resource.data.diff(resource.data)
                        .changedKeys().hasOnly(['rating']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasOnly(['review']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasOnly(['ratingImageUrl']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasOnly(['hasRating']) ||
                       // Allow combinations of rating fields
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['rating', 'review']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['rating', 'ratingImageUrl']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['rating', 'hasRating']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['review', 'ratingImageUrl']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['review', 'hasRating']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['ratingImageUrl', 'hasRating']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['rating', 'review', 'ratingImageUrl']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['rating', 'review', 'hasRating']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['rating', 'ratingImageUrl', 'hasRating']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['review', 'ratingImageUrl', 'hasRating']) ||
                       request.resource.data.diff(resource.data)
                        .changedKeys().hasAll(['rating', 'review', 'ratingImageUrl', 'hasRating'])));
      
      // Only admin can delete orders
      allow delete: if isAdmin();
      
      // Rating subcollection - customers can add ratings to their own orders
      match /rating/{ratingId} {
        allow create: if isSignedIn() && 
                         get(/databases/$(database)/documents/orders/$(orderId)).data.customerId == request.auth.uid;
        allow read: if isAdmin() || isStaff() || 
                       (isSignedIn() && 
                        get(/databases/$(database)/documents/orders/$(orderId)).data.customerId == request.auth.uid);
        allow update, delete: if isAdmin() || isStaff();
      }
    }

    // Notifications collection
    // FIXED: Allow authenticated users to read their own notifications even if their user document doesn't exist yet
    match /notifications/{noteId} {
      // Anyone can create notifications (for order notifications)
      allow create: if isSignedIn();
      
      // Users can read their own notifications - prioritize this check first for new users
      // Staff/Admin can read all notifications (only checked if user doc exists)
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid ||
                     isAdmin() || isStaff();
      
      // Users can update their own notifications (mark as read)
      // Staff/Admin can update any notification
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid ||
                       isAdmin() || isStaff();
      
      // Users can delete their own notifications
      // Staff/Admin can delete any notification
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid ||
                       isAdmin() || isStaff();
    }

    // Quotations collection
    match /quotations/{quotationId} {
      // Customers can create quotations with their own customerId
      allow create: if isSignedIn() && 
                       request.resource.data.customerId == request.auth.uid;
      
      // Customers can read their own quotations
      // Staff/Admin can read all quotations
      allow read: if isAdmin() || isStaff() || 
                     (isSignedIn() && resource.data.customerId == request.auth.uid);
      
      // Only staff/admin can update quotations
      allow update: if isAdmin() || isStaff();
      
      // Only admin can delete quotations
      allow delete: if isAdmin();
    }

    // Chats collection
    match /chats/{chatId} {
      allow read, write: if isSignedIn() &&
        (request.auth.uid in resource.data.participants ||
         request.auth.uid in request.resource.data.participants);

      match /messages/{messageId} {
        allow read, write: if isSignedIn() &&
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
      }
    }

    // OTP and Email collections (if you still use them)
    match /otps/{email} {
      allow create: if
        request.resource.data.email == email &&
        request.resource.data.code is string &&
        request.resource.data.code.size() == 6 &&
        request.resource.data.expiresAt is timestamp &&
        request.resource.data.expiresAt > request.time;
      allow delete: if request.auth != null && request.auth.token.email == email;
      allow read, update: if false;
    }

    match /mail/{id} {
      allow create: if
        (
          request.resource.data.to is string ||
          (request.resource.data.to is list && request.resource.data.to.size() > 0)
        ) &&
        request.resource.data.message is map &&
        request.resource.data.message.subject is string &&
        request.resource.data.message.text is string &&
        request.resource.data.message.html is string;
      allow read, update, delete: if false;
    }

    // Products collection - anyone can read, only admin/staff can write
    // Customers can update stock field only (for order creation stock deduction)
    match /products/{productId} {
      allow read: if true; // Anyone can read products
      allow create, delete: if isAdmin() || isStaff();
      
      // Allow customers to update only stock and updatedAt fields (for stock deduction during order creation)
      // Stock can only be decreased, not increased, and cannot go negative
      allow update: if isAdmin() || isStaff() ||
                     (isSignedIn() && 
                      // Only allow stock and updatedAt fields to be changed
                      request.resource.data.diff(resource.data)
                        .affectedKeys().hasOnly(['stock', 'updatedAt']) &&
                      // Stock must be a number
                      request.resource.data.stock is int &&
                      resource.data.stock is int &&
                      // Stock can only be decreased (not increased)
                      request.resource.data.stock < resource.data.stock &&
                      // Stock cannot go negative
                      request.resource.data.stock >= 0);
    }

    // OTP Verifications collection - for push notification OTP system
    // Allow creation during signup (unauthenticated users need to create OTP)
    match /otp_verifications/{otpId} {
      // Allow create during signup (unauthenticated) - validate OTP structure
      allow create: if request.resource.data.userId is string &&
                       request.resource.data.otpCode is string &&
                       request.resource.data.otpCode.size() == 6 &&
                       request.resource.data.expiresAt is timestamp &&
                       request.resource.data.expiresAt > request.time &&
                       request.resource.data.used == false &&
                       !('usedAt' in request.resource.data);
      
      // Allow read during verification (unauthenticated users need to verify OTP)
      // OTPs expire in 5 minutes and are single-use, so security risk is minimal
      allow read: if true;
      
      // Allow update only to mark as used (for OTP verification)
      // Can be done by unauthenticated users during signup verification
      allow update: if request.resource.data.diff(resource.data)
                      .affectedKeys().hasOnly(['used', 'usedAt']) &&
                    request.resource.data.used == true &&
                    resource.data.used == false;
      
      // No delete access
      allow delete: if false;
    }

    // OTP Last Sent collection - tracks cooldown between OTP requests
    match /otp_last_sent/{userId} {
      // Allow read/write during signup (unauthenticated users need to track cooldown)
      allow read, write: if request.resource.data.lastSentAt is timestamp;
    }

    // Activity Logs collection - for tracking system activities
    match /activity_logs/{logId} {
      // Anyone authenticated can create activity logs (for system logging)
      // Admin/Staff can read all activity logs
      allow create: if isSignedIn();
      allow read: if isAdmin() || isStaff();
      allow update, delete: if isAdmin();
    }

    // Default deny all other collections
    match /{document=**} { 
      allow read, write: if false; 
    }
  }
}

